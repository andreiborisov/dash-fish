/** \page tutorial Tutorial

\htmlonly[block]
<div class="fish_left_bar">
<div class="menu tutorial_menu">
\endhtmlonly
- <a href="#tut_why_fish">Why fish?</a>
- <a href="#tut_learning_Fish">Learning fish</a>
- <a href="#tut_running_commands">Running Commands</a>
- <a href="#tut_getting_help">Getting Help</a>
- <a href="#tut_syntax_highlighting">Syntax Highlighting</a>
- <a href="#tut_wildcards">Wildcards</a>
- <a href="#tut_pipes_and_redirections">Pipes and Redirections</a>
- <a href="#tut_autosuggestions">Autosuggestions</a>
- <a href="#tut_tab_completions">Tab Completions</a>
- <a href="#tut_variables">Variables</a>
- <a href="#tut_exit_status">Exit Status</a>
- <a href="#tut_exports">Shell Variables</a>
- <a href="#tut_lists">Lists</a>
- <a href="#tut_command_substitutions">Command Substitutions</a>
- <a href="#tut_combiners">Combiners (And, Or, Not)</a>
- <a href="#tut_conditionals">Conditionals (If, Else, Switch)</a>
- <a href="#tut_functions">Functions</a>
- <a href="#tut_loops">Loops</a>
- <a href="#tut_prompt">Prompt</a>
- <a href="#tut_startup">Startup</a>

\htmlonly[block]
</div>
</div>

<div class="tutorial fish_right_bar">
<h1 class="interior_title">fish tutorial</h1>
\endhtmlonly


\section tut_why_fish Why fish?

`fish` is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. `fish` supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.

If you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then `fish` might be just what you're looking for!


\section tut_learning_Fish Learning fish

This tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of `fish`.

If you have a strong understanding of other shells, and want to know what `fish` does differently, search for the magic phrase <i>unlike other shells</i>, which is used to call out important differences.

When you start `fish`, you should see this:

\fish{cli-dark}
Welcome to fish, the friendly interactive shell
Type <em>help</em> for instructions on how to use fish
you@hostname <em>~</em>>
\endfish

`fish` comes with a default prompt that shows your username, hostname, and working directory. You'll see <a href="#tut_prompt">how to change your prompt</a> further down. From now on, we'll pretend your prompt is just a '`>`' to save space.


\section tut_running_commands Running Commands

`fish` runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:

\fish{cli-dark}
> <b>echo</b> <i>hello world</i>
hello world
\endfish

You can include a literal space in an argument with a backslash, or by using single or double quotes:

\fish{cli-dark}
> <b>mkdir</b> <i>My\ Files</i>
> <b>cp</b> <i>~/Some\ File</i> <i class=quote>'My Files'</i>
> <b>ls</b> <i class=quote>"My Files"</i>
Some File
\endfish

Commands can be chained with semicolons.


\section tut_getting_help Getting Help

`fish` has excellent help and man pages. Run `help` to open help in a web browser, and `man` to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.

\fish{cli-dark}
> <b>man</b> <i>set</i>
set - handle shell variables
  Synopsis...
\endfish


\section tut_syntax_highlighting Syntax Highlighting

You'll quickly notice that `fish` performs syntax highlighting as you type. Invalid commands are colored red by default:

\fish{cli-dark}
> <error>/bin/mkd</error>
\endfish

A command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:

\fish{cli-dark}
> <b>/bin/mkdir</b>
\endfish

`fish` will underline valid file paths as you type them:

\fish{cli-dark}
> <b>cat</b> <i><span style="text-decoration: underline">~/somef<span class="u">i</span></span></i>
\endfish

This tells you that there exists a file that starts with '`somefi`', which is useful feedback as you type.

These colors, and many more, can be changed by running `fish_config`, or by modifying variables directly.


\section tut_wildcards Wildcards

`fish` supports the familiar wildcard *. To list all JPEG files:

\fish{cli-dark}
> <b>ls</b> <i>*.jpg</i>
lena.jpg
meena.jpg
santa maria.jpg
\endfish

You can include multiple wildcards:

\fish{cli-dark}
> <b>ls</b> <i>l*.p*</i>
lena.png
lesson.pdf
\endfish

Especially powerful is the <i>recursive wildcard</i> ** which searches directories recursively:

\fish{cli-dark}
> <b>ls</b> <i>/var/\**.log</i>
/var/log/system.log
/var/run/sntp.log
\endfish

If that directory traversal is taking a long time, you can @key{Control,C} out of it.


\section tut_pipes_and_redirections Pipes and Redirections

You can pipe between commands with the usual vertical bar:

\fish{cli-dark}
> <b>echo</b> <i>hello world</i> | <b>wc</b>
       1       2      12
\endfish

stdin and stdout can be redirected via the familiar &lt; and &gt;. Unlike other shells, stderr is redirected with a caret ^

\fish{cli-dark}
> <b>grep</b> <i>fish</i> &lt; /etc/shells > ~/output.txt ^ ~/errors.txt
\endfish


\section tut_autosuggestions Autosuggestions

`fish` suggests commands as you type, and shows the suggestion to the right of the cursor, in gray. For example:

\fish{cli-dark}
> <b class="error">/bin/h</b><span class="suggest"><span class="u">o</span>stname</span>
\endfish

It knows about paths and options:

\fish{cli-dark}
> <b>grep</b> <i>--i<span class="suggest"><span class="u">g</span>nore-case</span></i>
\endfish

And history too. Type a command once, and you can re-summon it by just typing a few letters:

\fish{cli-dark}
> <b>r</b><span class="suggest"><span class="u">s</span>ync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo</span>
\endfish

To accept the autosuggestion, hit right arrow or @key{Control,F}. To accept a single word of the autosuggestion, @key{Alt,&rarr;} (right arrow). If the autosuggestion is not what you want, just ignore it.


\section tut_tab_completions Tab Completions

`fish` comes with a rich set of tab completions, that work "out of the box."

Press tab, and `fish` will attempt to complete the command, argument, or path:

\fish{cli-dark}
> <b class="error">/pri</b><span class="meta">&lt;tab&gt; &rarr;</span> <b>/private/</b>
\endfish

If there's more than one possibility, it will list them:

\fish{cli-dark}
> <b class="error">~/stuff/s</b><span class="meta">&lt;tab&gt;</span>
<i>~/stuff/s</i>cript.sh  <i class="quote">(Executable, 4.8kB)</i>  <i>~/stuff/s</i>ources/  <i class="quote">(Directory)</i>
\endfish

Hit tab again to cycle through the possibilities.

`fish` can also complete many commands, like git branches:

\fish{cli-dark}
> <b>git</b> <i>merge pr</i><span class="meta">&lt;tab&gt; &rarr;</span> git merge prompt_designer
> <b>git</b> <i>checkout b</i><span class="meta">&lt;tab&gt;</span>
<i>b</i>uiltin_list_io_merge  <i class="quote">(Branch)</i>  <i>b</i>uiltin_set_color  <i class="quote">(Branch)</i>  <i>b</i>usted_events  <i class="quote">(Tag)</i>
\endfish

Try hitting tab and see what `fish` can do!


\section tut_variables Variables

Like other shells, a dollar sign performs <i>variable substitution</i>:

\fish{cli-dark}
> <b>echo</b> <i>My home directory is $HOME</i>
My home directory is /home/tutorial
\endfish

Variable substitution also occurs in double quotes, but not single quotes:

\fish{cli-dark}
> <b>echo</b> <i class="quote">"My current directory is </i><i>$</i><i class="quote">PWD"</i>
My current directory is /home/tutorial
> <b>echo</b> <i class="quote">'My current directory is $PWD'</i>
My current directory is $PWD
\endfish

Unlike other shells, `fish` has no dedicated syntax for setting variables. Instead it has an ordinary command: `set`, which takes a variable name, and then its value.

\fish{cli-dark}
> <b>set</b> <i>name</i> <i class="quote">'Mister Noodle'</i>
> <b>echo</b> <i>$name</i>
Mister Noodle
\endfish

(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a <i>list</i> of two elements.)

Unlike other shells, variables are <i>not</i> further split after substitution:

\fish{cli-dark}
> <b>mkdir</b> <i>$name</i>
> <b>ls</b>
Mister Noodle
\endfish

In bash, this would have created two directories "Mister" and "Noodle". In `fish`, it created only one: the variable had the value "Mister Noodle", so that is the argument that was passed to <span style="mono">mkdir</span>, spaces and all.


\section tut_exit_status Exit Status

Unlike other shells, `fish` stores the exit status of the last command in `$status` instead of `$?`.

\fish{cli-dark}
> <b>false</b>
> <b>echo</b> <i>$status</i>
1
\endfish

Zero is considered success, and non-zero is failure.

<h2 id="tut_exports">Exports (Shell Variables)</h2>

Unlike other shells, `fish` does not have an export command. Instead, a variable is exported via an option to `set`, either `--export` or just `-x`.

\fish{cli-dark}
> <b>set</b> <i>-x MyVariable SomeValue</i>
> <b>env</b> | <b>grep</b> <i>MyVariable</i>
<span style="background: #A0A">MyVariable</span>=SomeValue
\endfish

You can erase a variable with `-e` or `--erase`

\fish{cli-dark}
> <b>set</b> <i>-e MyVariable</i>
> <b>env</b> | <b>grep</b> <i>MyVariable</i>
<span class="meta">(no output)</span>
\endfish


\section tut_lists Lists

The `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a <i>list</i> of length 2.  In fact, all variables in `fish` are really lists, that can contain any number of values, or none at all.

Some variables, like `$PWD`, only have one value. By convention, we talk about that variable's value, but we really mean its <i>first</i> (and only) value.

Other variables, like `$PATH`, really do have multiple values. During <i>variable expansion</i>, the variable expands to become multiple arguments:

\fish{cli-dark}
> <b>echo</b> <i>$PATH</i>
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
\endfish

Lists cannot contain other lists: there is no recursion.  A variable is a list of strings, full stop.

Get the length of a list with `count`:

\fish{cli-dark}
> <b>count</b> <i>$PATH</i>
5
\endfish

You can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to $PATH:

\fish{cli-dark}
> <b>set</b> <i>PATH $PATH /usr/local/bin</i>
\endfish


You can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:

\fish{cli-dark}
> <b>echo</b> <i>$PATH</i>
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
> <b>echo</b> <i>$PATH[1]</i>
/usr/bin
> <b>echo</b> <i>$PATH[-1]</i>
/usr/local/bin
\endfish

You can also access ranges of elements, known as "slices:"

\fish{cli-dark}
> <b>echo</b> <i>$PATH[1..2]</i>
/usr/bin /bin
> <b>echo</b> <i>$PATH[-1..2]</i>
/usr/local/bin /sbin /usr/sbin /bin
\endfish

You can iterate over a list (or a slice) with a <i>for loop</i>:

\fish{cli-dark}
> <b>for</b> <i>val</i> <b>in</b> <i>$PATH</i>
    <b>echo</b> <i>"entry: $val"</i>
  <b>end</b>
entry: /usr/bin/
entry: /bin
entry: /usr/sbin
entry: /sbin
entry: /usr/local/bin
\endfish


\section tut_command_substitutions Command Substitutions

Command substitutions use the output of one command as an argument to another. Unlike other shells, `fish` does not use backticks ` for command substitutions. Instead, it uses parentheses:

\fish{cli-dark}
> <b>echo</b> <i>In (</i><b>pwd</b><i>), running (</i><b>uname</b><i>)</i>
In /home/tutorial, running FreeBSD
\endfish

A common idiom is to capture the output of a command in a variable:

\fish{cli-dark}
> <b>set</b> <i>os (</i><b>uname</b><i>)</i>
> <b>echo</b> <i>$os</i>
Linux
\endfish

Command substitutions are not expanded within quotes. Instead, you can temporarily close the quotes, add the command substitution, and reopen them, all in the same argument:

\fish{cli-dark}
> <b>touch</b> <i class="quote">"testing_"</i><i>(</i><b>date</b> <i>+%s</i><i>)</i><i class="quote">".txt"</i>
> <b>ls</b> <i>*.txt</i>
testing_1360099791.txt
\endfish

<h2 id="tut_combiners">Combiners (And, Or, Not)</h2>

Unlike other shells, `fish` does not have special syntax like &amp;&amp; or || to combine commands. Instead it has commands `and`, `or`, and `not`.

\fish{cli-dark}
> <b>cp</b> <i>file1.txt file1_bak.txt</i>; <b>and echo</b> <i class="quote">"Backup successful"</i>; <b>or echo</b> <i class="quote">"Backup failed"</i>
Backup failed
\endfish

<h2 id="tut_conditionals">Conditionals (If, Else, Switch)</h2>

Use `if`, `else if`, and `else` to conditionally execute code, based on the exit status of a command.

\fish{cli-dark}
<b>if grep</b> <i>fish /etc/shells</i>
    <b>echo</b> <i>Found fish</i>
<b>else if grep</b> <i>bash /etc/shells</i>
    <b>echo</b> <i>Found bash</i>
<b>else</b>
    <b>echo</b> <i>Got nothing</i>
<b>end</b>
\endfish

There is also a `switch` command:

\fish{cli-dark}
<b>switch</b> <i>(</i><b>uname</b><i>)</i>
<b>case</b> <i>Linux</i>
    <b>echo</b> <i>Hi Tux!</i>
<b>case</b> <i>Darwin</i>
    <b>echo</b> <i>Hi Hexley!</i>
<b>case</b> <i>FreeBSD NetBSD DragonFly</i>
    <b>echo</b> <i>Hi Beastie!</i>
<b>case</b> <i class="quote">'*'</i>
    <b>echo</b> <i>Hi, stranger!</i>
<b>end</b>
\endfish

Note that `case` does not fall through, and can accept multiple arguments or (quoted) wildcards.


\section tut_functions Functions

A `fish` function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in "numbered variables" like `$1`, but instead in a single list `$argv`. To create a function, use the `function` builtin:

\fish{cli-dark}
> <i><b>function</b> say_hello
     <b>echo</b> Hello $argv
  <b>end</b></i>
> <b>say_hello</b>
Hello
> <b>say_hello <i>everybody!</i></b>
Hello everybody!
\endfish

Unlike other shells, `fish` does not have aliases or special prompt syntax. Functions take their place.

You can list the names of all functions with the `functions` keyword (note the plural!). `fish` starts out with a number of functions:

\fish{cli-dark}
> <b>functions</b>
alias, cd, delete-or-exit, dirh, dirs, down-or-search, eval, export, fish_command_not_found_setup, fish_config, fish_default_key_bindings, fish_prompt, fish_right_prompt, fish_sigtrap_handler, fish_update_completions, funced, funcsave, grep, help, history, isatty, ls, man, math, nextd, nextd-or-forward-word, open, popd, prevd, prevd-or-backward-word, prompt_pwd, psub, pushd, seq, setenv, sgrep, trap, type, umask, up-or-search, vared
\endfish

You can see the source for any function by passing its name to `functions`:

\fish{cli-dark}
> <b>functions</b> <i>ls</i>
function ls --description 'List contents of directory'
    command ls -G $argv
end
\endfish


\section tut_loops Loops

While loops:

\fish{cli-dark}
> <b>while</b> <i>true</i>
    <b>echo</b> <i class="quote">"Loop forever"</i>
<b>end</b>
Loop forever
Loop forever
Loop forever
...
\endfish

For loops can be used to iterate over a list. For example, a list of files:

\fish{cli-dark}
> <b>for</b> <i>file in *.txt</i>
    <b>cp</b> <i>$file $file.bak</i>
<b>end</b>
\endfish

Iterating over a list of numbers can be done with `seq`:

\fish{cli-dark}
> <b>for</b> <i>x in (</i><b>seq</b> <i>5)</i>
    <b>touch</b> <i>file_$x.txt</i>
<b>end</b>
\endfish


\section tut_prompt Prompt

Unlike other shells, there is no prompt variable like PS1. To display your prompt, `fish` executes a function with the name `fish_prompt`, and its output is used as the prompt.

You can define your own prompt:

\fish{cli-dark}
> <b>function</b> <i>fish_prompt</i>
    echo <i>"New Prompt % "</i>
<b>end</b>
New Prompt % <span class="u"> </span>
\endfish

Multiple lines are OK. Colors can be set via `set_color`, passing it named ANSI colors, or hex RGB values:

\fish{cli-dark}
> <b>function</b> <i>fish_prompt</i>
      <b>set_color</b> <i>purple</i>
      <b>date</b> <i class="quote">"+%m/%d/%y"</i>
      <b>set_color</b> <i>FF0</i>
      <b>echo</b> <i>(</i><b>pwd</b><i>)</i> <i class="quote">'>'</i>
      <b>set_color</b> <i>normal</i>
  <b>end</b>
<span style="color: purple">02/06/13</span>
<span style="color: #FF0">/home/tutorial ></span><span class="u"> </span>
\endfish

You can choose among some sample prompts by running `fish_config prompt`. `fish` also supports RPROMPT through `fish_right_prompt`.

\subsection tut-path $PATH

`$PATH` is an environment variable containing the directories in which `fish` searches for commands. Instead of separating entries with a colon, $PATH is a list. You can modify $PATH in a few ways:

-# By modifying the `$fish_user_paths` variable, which is automatically appended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:

\fish{cli-dark}
> <b>set</b> <i>-U fish_user_paths $fish_user_paths /usr/local/bin</i>
\endfish

-# Directly in config.fish (see below).

<h2 id="tut_startup">Startup (Where's .bashrc?)</h2>

`fish` starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.

It is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:

\fish{cli-dark}
> <b>cat</b> <i>~/.config/fish/config.fish</i>

set -x PATH $PATH /sbin/

function ll
    ls -lh $argv
end
\endfish

However, it is more common and efficient to use  <i>autoloading functions</i> and <i>universal variables</i>.

\subsection tut-autoload Autoloading Functions

When `fish` encounters a command, it attempts to <i>autoload</i> a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.

For example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:

\fish{cli-dark}
> <b>cat</b> <i>~/.config/fish/functions/ll.fish</i>
function ll
    ls -lh $argv
end
\endfish

This is the preferred way to define your prompt as well:

\fish{cli-dark}
> <b>cat</b> <i>~/.config/fish/functions/fish_prompt.fish</i>
function fish_prompt
    echo (pwd) '> '
end
\endfish

See the documentation for <a href="commands.html#funced">funced</a> and <a href="commands.html#funcsave">funcsave</a> for ways to create these files automatically.

\subsection tut-universal Universal Variables

A universal variable is a variable whose value is shared across all instances of `fish`, now and in the future - even after a reboot. You can make a variable universal with `set -U`:

\fish{cli-dark}
> <b>set</b> <i>-U EDITOR vim</i>
\endfish

Now in another shell:

\fish{cli-dark}
> <b>echo</b> <i>$EDITOR</i>
vim
\endfish

\subsection tut-more  Ready for more?

If you want to learn more about fish, there is <a href="index.html">lots of detailed documentation</a>, an <a href="https://lists.sourceforge.net/lists/listinfo/fish-users">official mailing list</a>, the IRC channel \#fish on `irc.oftc.net`, and the <a href="http://github.com/fish-shell/fish-shell/">github page</a>.

\htmlonly[block]
</div>
\endhtmlonly
*/
